# Function interface

Goal for today is focus on the interface of functions, because I think this is an important change in mindset when you start developing functions. You have to think how they fit together into a greater whole.

* interface = outside
* implementation = inside

More: <http://design.tidyverse.org/>

## Your Turn: Poll

What are the properties of a function that define its interface? (Hint: There are at least 9!)

Timed: 3 minutes

* Name
* Inputs (i.e. arguments)
  * Names
  * Types
  * Defaults
* Output
* Errors (and other conditions)
* Side-effects
  * Saving files
  * Messaging to user

```{r setup}
library(stringr)
```

## base R vs stringr

Base R string functions aren't bad or wrong! All functions can be improved, and it's useful to critique existing work.

### Your Turn: Breakout rooms

10 minutes

Discuss:
* What are some of the challenges of the base string functions? 
  * Think particularly about names, arguments, and outputs.

Then:
* Answer the sli.do questions

```{r, eval = FALSE}
strsplit(x, split, ...)
grep(pattern, x, value = FALSE, ...)
grepl(pattern, x, ...)
sub(pattern, replacement, x, ...)
gsub(pattern, replacement, x, ...)
regexpr(pattern, text, ...)
gregexpr(pattern, text, ...)
regexec(pattern, text, ...)
substr(x, start, stop)
nchar(x, type, ...)
```

* Names
  * No common theme. 
  * No common prefix. 
  * Names are concise, but confusing. (who is Greg?)
  * Difficult to remember, and distinguish.
  
* Arguments
  * Argument names & order are not consistent
  * Data isn’t the first argument (2nd or 3rd). 
  * Sometimes `text`, sometimes `x`. 
  * Not always independent.

* Outputs:
  * Can’t feed output of `gregexpr()` into `substr()`

## Names

The name of a function is a very important part of its interface.

* Helps you remember functionality.
* Need name (or part of a name) to look up.

### Function names should be verbs (usually)

Because they _do_ something

### Your Turn: Breakout rooms

Match the following functions and arguments to their stringr equivalents. What are some issues with the base functions? What are some issues with the stringr equivalents?

```{r}
grepl(value = TRUE) 
grep()              
grepl()           
sub()             
gsub()            
strsplit()        
regexpr()         
```

```{r}
grepl(value = TRUE) # -> str_subset()
grep()              # -> str_which() 
grepl()             # -> str_detect()
sub()               # -> str_replace()
gsub()              # -> str_replace_all()
strsplit()          # -> str_split()
regexpr()           # -> str_locate()
```

Some problems: what's the difference between `str_detect()`, `str_which()`, and `str_subset()`? Differ primarily in their output type. English verbs too similar:

```{r}
str_detect() # str_something_lgl() ?
str_which()  # str_something_int() ?
str_subset() # str_something_chr() ?
```

Another way to think about it is that some function work with chararacters in a string, which others work with strings in a character vector.

```{r}
str_locate_vec()
str_locate_str()
```


Verbs aren't always essential. Nouns can work when you're building up objects.

For example, most ggplot2 functions aren't verbs. 

```{r, eval = FALSE}
library(ggplot2)

geom_line()
scale_x_continuous()
coord_fixed()
```

Nouns can also work if you're extracting a property:

```{r, eval = FALSE}
str_length()
```

And sometimes there just isn't a good verb:

```{r}
str_to_lower()
str_to_upper()
```

Function names:

* Should probably be verbs.
* Should be clear and concise. 
* Should distinguish a function from related functions.


### Prefixes and suffixes

* `snake_case` vs `camelCase`. Pick one and be consistent. (avoid being like `install.packages()`).

* Use prefixes to group together related functions. 
  Main advantage is autocomplete. 
  Not necessary to have common prefix for every function in package.

* Use suffixes for variations on a theme.
    * `str_replace()` and `str_replace_all()`
    * `str_split()` and `str_split_fixed()`

When should you make multiple functions rather than using an argument? If it changes the _type_ of output, always make it a function. If the argument would interact with other arguments, probably should be a function.  

If there are many options, an argument probably better. Sometimes only obvious in retrospect.

```{r}
# Sarted with
str_to_upper()
str_to_lower()
# Then added
str_to_title()
str_to_sentence()

# probably should be
str_capitalise(x, to = "upper")
str_capitalise(x, to = "lower")
str_capitalise(x, to = "title")
str_capitalise(x, to = "sentence")
# BUT
str_capitalize() # ?
```

### Guidelines for function names

Function names should:
* Probably be verbs.
* Be clear and concise. 
* Distinguish a function from related functions.
* (if relevant) use prefixes to group together related functions.
* (if relevant) use suffixes to identify functions that are variants of each other.


### Advice

* Try a thesaurus.
* Choose dense words.
* Edit down. There is other context besides just the function name. (i.e., mutate(), not mutate_data_frame())
* If you're stuck, try writing down exactly what you're function does. (half-truth: unclear writing is unclear thinking)
* Consume good function names.

<!--1 hour-->

## Arguments

* Types
* Required arguments
* Hidden arguments
* Enumms
* Keeping arguments independent

## Types

Arguments can be:

* Required / not required
* Hidden / not hidden
* Enumerated / not enumerated
* Independent / dependent

### Your turn: Breakout rooms

Divide the arguments of the following functions into groups. For each group, determine whether the arguments are required or optional. 

```{r}
strsplit(x, split, fixed = TRUE)
grepl(pattern, x, fixed = TRUE, ignore.case = TRUE)
gsub(pattern, replacement, x, fixed = TRUE, ignore.case = TRUE)
gregexpr(pattern, text, fixed = TRUE)
substr(x, start, stop)
```

### Data, descriptors, and details

* Data: `x`, `text`. 

  * Primary vector of data. Often called `x` or `data`.
  * Required. Controls shape/type of output

* Descriptors: `pattern`, `replacement`, `start`, `stop`. 
  
  * Essential features of the operation to be carried out.
  * Required. 

* Details: `fixed`, `ignore.case`, `perl`, `useBytes`, etc.
  
  * Additional details. 
  * Optional.
  
Order:

1. Data
2. Descriptors
(3. `...`)
4. Details

Benefits:

* Works with pipe.
* Ordered from most important to least important
* Required arguments come before optional. 
* Forces details to be named.

### Required

#### Your turn: Poll

Which of `sample()`'s arguments are required?

2 min

Simple rule:
* Required <-> no default
* Optional <-> has default

### Hidden

Avoid hidden arguments.

Hidden arguments: when a function returns *surprisingly* different results on the same input.

```{r}
tolower("I")
sort(letters)
```

```{r}
str_to_lower("I")
str_to_lower("I", locale = "tr")

# https://en.wikipedia.org/wiki/Swedish_alphabet
str_sort(c("a", "o", "z", "å", "ø"))
str_sort(c("a", "o", "z", "å", "ø"), locale = "se")

# readr::locale()
```

Not hidden, because not surprising:

```{r}
Sys.time()
lubridate::today()
rnorm(1)
```

### Enums

```{r}
str_trim()
str_trunc()
rank()
```

Use if you have an argument that takes a small set of possible values. 

*Key*: use `match.arg()`

### Independence

Arguments are dependent if the possibilities for one depends on the values of another.

```{r}
# Can supply times and each, unless times is a vector
rep(1:3, times = 2, each = 3)
rep(1:3, times = 1:3, each = 2)
```

Keep arguments independent. More confusing for you, and more confusing for the user.

https://design.tidyverse.org/args-independence.html#how-do-i-remediate

### Type stability

Starting point: a function should always return the same type. 

```{r}
rnorm(n = 1)
str_trim(" abc ")
```

#### Your turn: Poll

2 min

Does `sum()` always return the same type?

More nuanced: a function's output type should be easy to predict based on it's inputs.

```{r}
if_else()
c()
sum()
```

# End-of-day survey

Please fill out on sli.do.
