# Dependencies

How and when to use code from other packages.

* Motivation
* Scoping: how functions find variables
* `NAMESPACE`
* `DESCRIPTION`
* When should you take a dependency?


## Live coding

Going to switch formats to live coding. 

I will regularly check my notes into Github. 

bit.ly/build-tt

`notes/4-dependencies.Rmd`

## Motivation

```{r}
sd
```

```{r}
x <- c(1, 1, 5, 9, 9)
sd(x)
```

```{r}
var <- function(x, na.rm = FALSE){
  100
}
```

What will we get when we run?:
```{r}
sd(x)
```
Answer in:
slido.com #80875 
passcode: tidytools

```{r}
my_sd <- function(x){
  sqrt(var(x))
}
```

What will happen if we run:
```{r}
my_sd(x)
```
Answer in:
slido.com #80875 
passcode: tidytools

What will `f()` return?
```{r}
x <- 1
y <- 1
z <- 1
f <- function() {
  y <- 2
  z <- 2
  g <- function() {
    z <- 3
    c(x, y, z)
  }
  g()
}
f()
```
* 1, 1, 1
* 1, 1, 3
* 1, 2, 2
* 1, 2, 3

slido.com #80875 
passcode: tidytools

### Your Turn: Breakout Rooms

Discuss:  

* What does `f()` return?  
* What are the rules R uses to find a variable?

Timed: 4 minutes

What does `f` return?
```{r}
f()
```

## Scoping Rules

Rules that R uses to find variables.

R looks in the current environment first.
If R can't find it, R looks in the parent environment,
If R can't find it there, R looks in the parent environment,
and so, until it finds it, 
or it reach the empty environment.

The parent environment of a function is where it was 
defined (not called).

These same rules are followed for functions you've defined,
or for function inside packages.

useful functions from rlang:

```{r}
library(rlang)
get_env(my_sd)
env_print(get_env(my_sd))
# Q: for Charlotte why is parent rlang
```

```{r}
get_env(sd)
env_print(get_env(sd))
env_has(get_env(sd), "var")
env_parents(get_env(sd))
```
```{r}
get_env(ggplot2::geom_point)
env_parents(get_env(ggplot2::geom_point))
```
```{r}
get_env(dplyr::mutate)
env_parents(get_env(dplyr::mutate))
```

Always the same. 
Functions used in a package function
will first be looked for in the package namespace,
`namespace:package_name`
(i.e. all functions in the package),
then in the package imports, `imports:package_name`
then in the base package, 
then in the global environment.

To use functions from other packages
in yours, 
you'll need to define the contents of the
import environemnt.

## Adding Dependencies to your Package

**Your Turn** - Breakout Rooms

Get the ns package:
```{r}
usethis::create_from_github("cwickham/ns", fork = FALSE)
```

* `check()`. You should get a `NOTE` about `"Undefined global functions"`

* Fix the problem. Include this in the Roxygen comments
above the `my_sd()` function:
```{r}
#' @importFrom stats var
```

* `check()` to verify the `NOTE` is removed.

(~ 6 mins)

**Ready to move on?** Indicate in the Google Doc.

While you wait, open the `NAMESPACE` file, 
can you tell how it has changed?

### An Alternative Solution

Don't use `#' @importFrom`, use `::` instead, e.g.
```{r}
#' My standard deviation function
#'
#' @param x A numeric vector
#' @export
my_sd <- function (x) {
  sqrt(stats::var(x))
}
```

Why didn't we get a note for `sqrt()`? It's in the base
package.

### Non-base packages

Things work a little differently (more obviously) when you're using a package in a non-base package:

```{r}
my_count <- function(x) {
  df <- tibble(x = x)
  count(df, x)
}
```

```{r}
check()
```

```{r}
check()
```

```
> checking R code for possible problems ... NOTE
  my_count: no visible global function definition for ‘tibble’
  my_count: no visible global function definition for ‘count’
```

Fix with `::`:
```{r}
my_count <- function(x) {
  df <- tibble::tibble(x = x)
  dplyr::count(df, x)
}
```

But you'll get a new `WARNING`  on `check()`:
```
> checking dependencies in R code ... WARNING
  '::' or ':::' imports not declared from:
    ‘dplyr’ ‘tibble’
```

This is a cryptic warning!  But, it indicates,
a package level problem, we haven't indicated
that a user needs `dplyr` and `tibble` installed,
for our code to work.

This change happens in the `DESCRIPTION`, easiest
with:
```{r}
usethis::use_package("dplyr")
usethis::use_package("tibble")
```

In `DESCRPITION`
```
...
Imports: 
    dplyr,
    tibble
```

Why didn't stats need this? Because it's a recommended package; so R knows that it's always going to be avaiable/installed.

* `DESCRIPTION` is all about package level. You need to maintain.
* `NAMESPACE` is at function level. Use documentation to maintain.

**Your Turn** Breakout Rooms

1. Add this function to your ns package
    ```{r}
    my_count <- function(x) {
      df <- tibble(x = x)
      count(df, x)
    }
    ```
2. (Optional) Document the function

3. Get `check()` passing.
  * refer to functions explicitly `::`
  * `use_package()`

Ready to move on?  Check in with your group.
When everyone is ready, one person, answer the poll.

While you wait... re-write `my_count()` to use
the pipe `%>%`, then get `check()` passing.  
Hint: `?usethis::use_pipe()`

